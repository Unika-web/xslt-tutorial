<html >

<head>
<script src="http://www.google.com/jsapi"></script>
<script src="/Javascript/old_zvon.js" type="text/javascript" ></script>
<script>google.load("jquery", "1");

</script>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<title>Raleigh.ru - XSLT в примерах</title>
<link REL="stylesheet" TYPE="text/css" HREF="main.css" TITLE="Style">
</head>
<body><script type="text/javascript">                    
                    var _gaq = _gaq || [];
                    _gaq.push(['_setAccount', 'UA-15189975-1']);
                    _gaq.push(['_trackPageview']);
                    
                    (function() {
                    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ga);
                    })();
                    </script>
                    
<table cellpadding="0" cellspacing="0" width="100%" border="0">
	<tr><td width="100%" valign="bottom"
		background="../../Images/menu_grey.gif"><span
		style="background:url(../../Images/back.gif);
		color:#ffffff;font-family:courier">
		&nbsp;<a href="../../" style="color:#ffffff;" onFocus=blur();>Главная</a> -> <a 
		href="../" style="color:#ffffff;" onFocus=blur();>XML&...</a> -> XSLT в примерах&nbsp;</span></td>
	</tr>
</table>
<table class="hangingMenu" border="0" cellpadding="1" cellspacing="0" width="100%"><tr>
	<td width="100%" align="right"><b>&gt;&gt; Содержание &lt;&lt;</b> | <a class="naviBlack" href="elementIndex.htm">Указатель</a></td>
</tr></table><br>
<h3>Введение</h3>
<table cellPadding=5 border=1>
  <tbody>
  <tr>
    <td><a href="1.htm">Страница&nbsp;1</a></td>
    <td><a name=id1></a>С XSL вы можете свободно модифицировать исходный текст. Так с помощью <a href="1.htm#id4">этого</a> и <a href="1.htm#id5">этого преобразований</a> можно получить различный результат из одного исходного файла.</td></tr>
  <tr>
    <td><a href="2.htm">Страница&nbsp;2</a></td>
    <td><a name=id2></a>Каждое преобразование XSL должно начинаться с элемента <code>xsl:stylesheet</code>. Атрибут <code>version='1.0'</code> определяет версию спецификации XSL. Этот пример представляет собой простейшее возможное преобразование. Поскольку оно не содержит чего-либо помимо заголовка, то используется обработка по умолчанию.</td></tr>
  <tr>
    <td><a href="3.htm">Страница&nbsp;3</a></td>
    <td><a name=id3></a>XSLT-процессоры анализируют исходный XML и пытаются найти подходящий XSL-шаблон. Если такой шаблон найден, то выполняются инструкции внутри него.</td></tr>
  <tr>
    <td><a href="4.htm">Страница&nbsp;4</a></td>
    <td><a name=id4></a>Содержание элементов может быть извлечено из исходного документа двумя основными способами. <a href="4.htm#id5">Это преобразование</a> использует инструкцию <code>xsl:value-of</code>. В этом случае содержание элемента используется без какой-либо дальнейшей обработки. Инструкция <code>xsl:apply-templates</code> в <a href="4.htm#id6">этом преобразовании</a> действует по-другому. Здесь XSLT-процессор продолжает обрабатывать выбранные элементы, для которых определен шаблон.</td></tr></tbody></table>
<h3>Шаблоны</h3>
<table cellPadding=5 border=1>
  <tbody>
  <tr>
    <td><a href="5.htm">Страница&nbsp;5</a></td>
    <td><a name=id5></a>XSLT-процессоры анализируют исходный XML и пытаются найти подходящий XSL-шаблон. Если такой шаблон найден, то выполняются инструкции внутри него.</td></tr>
  <tr>
    <td><a href="6.htm">Страница&nbsp;6</a></td>
    <td><a name=id6></a>Части XML-документа, к которым должен применяться шаблон, определяются путями адресации. Их синтаксис описан в Спецификации XPath. В простейших случаях он очень похож на адресацию файловой системы (<a href="6.htm#id2">это преобразование</a>).</td></tr>
  <tr>
    <td><a href="7.htm">Страница&nbsp;7</a></td>
    <td><a name=id7></a>Обработка всегда начинается с шаблона, где <code>match="/"</code>. Это значение пути адресации соответствует корневому узлу (в нашем случае <code>source</code>). Однако многие преобразования XSL не содержат такой шаблон явно. В этом случае используется неявный шаблон (он содержит только единственную инструкцию). Эта инструкция обозначает: обрабатывать все дочерние элементы текущего узла, включая текстовые узлы. Сравните <a href=7.htm"#id2">это</a> и <a href="7.htm#id3">это преобразования</a>. Когда шаблон для узла существует, никакой обработки по умолчанию не происходит (<a href="7.htm#id4">это преобразование</a>). Если вы хотите включить обработку потомков узла, то вы должны явно указать шаблоны для них (<a href="7.htm#id5">это преобразование</a>).</td></tr>
  <tr>
    <td><a href="8.htm">Страница&nbsp;8</a></td>
    <td><a name=id8></a>Соответствие шаблонов определяется путями адресации, где конкретные пути разделяются с помощью символа "|" (<a href="8.htm#id2">это преобразование</a>). Символ "*" обозначает все возможности. Сравните <a href="8.htm#id2">это</a> и <a href="8.htm#id3">это преобразования</a>.</td></tr>
  <tr>
    <td><a href="9.htm">Страница&nbsp;9</a></td>
    <td><a name=id9></a>"//" очень часто встречается в путях адресации. Когда он используется в начале пути адресации, он обозначает: выбрать все узлы определенного типа в документе (<a href="9.htm#id2">это преобразование</a>). Внутри пути адресации он обозначает: выбрать все узлы, являющиеся потомками узла, указанного в первой части пути адресации (<a href="9.htm#id3">это преобразование</a>).</td></tr>
  <tr>
    <td><a href="10.htm">Страница&nbsp;10</a></td>
    <td><a name=id10></a>С помощью режимов (modes) элемент может быть обработан многократно, причем каждый раз с различным результатом. В <a href="#id3">этом преобразовании</a> один из режимов не существует.</td></tr>
  <tr>
    <td><a href="11.htm">Страница&nbsp;11</a></td>
    <td><a name=id11></a>Достаточно часто несколько шаблонов соответствует одному и тому же элементу в исходном XML. Поэтому надо решить, какой из них следует использовать. Для этого можно определить приоритеты с помощью атрибута <code>priority</code>. Если этот атрибут не определен, его приоритет вычисляется в соответствии с несколькими правилами. <a href="11.htm#id2">Это</a> и <a href="11.htm#id3">это преобразования</a> различаются приоритетами их шаблонов. <a href="11.htm#id4">Это преобразование</a> показывает действие по умолчанию в отсутствие атрибутов <code>priority</code>. Шаблон CCC имеет меньший приоритет по сравнению с CCC/CCC, поскольку он менее специфичный. Сравните <a href="11.htm#id5">это</a> и <a href="11.htm#id6">это преобразования</a>. Шаблон CCC имеет меньший приоритет, чем CCC/CCC или AAA/CCC/CCC, хотя два последних имеют одинаковый приоритет. В таком случае XSLT-процессор может сообщить об ошибке. Если этого не произошло, XSLT-процессор должен выбрать среди соответствующих шаблонов тот, который будет последним в преобразовании. В <a href="11.htm#id7">этом преобразовании</a> менее специфичный "*" имеет меньший приоритет по сравнению с CCC. Вычисленные приоритеты располагаются в диапозоне от -0.5 до 0.5. Более подробная информация содержится в Спецификации XSLT.</td></tr></tbody></table>
<h3>Атрибуты</h3>
<table cellPadding=5 border=1>
  <tbody>
  <tr>
    <td><a href="12.html">Страница&nbsp;12</a></td>
    <td><a name=id12></a>К атрибутам можно обращаться также, как и к элементам. Надо только поставить "@" перед именем атрибута.</td></tr>
  <tr>
    <td><a href="13.html">Страница&nbsp;13</a></td>
    <td><a name=id13></a>Атрибуты можно обрабатывать аналогично элементам.</td></tr>
  <tr>
    <td><a href="14.htm">Страница&nbsp;14</a></td>
    <td><a name=id14></a>Вы также можете выбирать элементы, которые содержат или не содержат данный атрибут. <a href="14.htm#id2">Это преобразование</a> включает, а  <a href="14.htm#id3">это преобразование</a> исключает элементы, если определенный элемент присутствует.</td></tr></tbody></table>
<h3>Оси</h3>
<table cellPadding=5 border=1>
  <tbody>
  <tr>
    <td><a href="15.htm">Страница&nbsp;15</a></td>
    <td><a name=id15></a>Оси играют очень важную роль в XSLT. Для более подробной информации читайте <a xmlns:xsl="http://www.w3.org/1999/XSL/Transform" href="http://zvon.org/xxl/XSLTreference/Output/index.html">XSLT reference</a>. Сравните: ось child (<a href="15.htm#id2">это преобразование</a>), ось descendant (<a href="15.htm#id3">это преобразование</a>), ось parent (<a href="15.htm#id4">это преобразование</a>), ось ancestor (<a href="15.htm#id5">это преобразование</a>), ось following-sibling (<a href="15.htm#id6">это преобразование</a>), ось preceding-sibling (<a href="15.htm#id7">это преобразование</a>), ось following (<a href="15.htm#id8">это преобразование</a>), ось preceding (<a href="15.htm#id9">это преобразование</a>), ось attribute (<a href="15.htm#id10">это преобразование</a>), ось namespace (<a href="15.htm#id11">это преобразование</a>), ось self (<a href="15.htm#id12">это преобразование</a>), ось descendant-or-self (<a href="15.htm#id13">это преобразование</a>), ось ancestor-or-self (<a href="15.htm#id14">это преобразование</a>).</td></tr>
  <tr>
    <td><a href="16.htm">Страница&nbsp;16</a></td>
    <td><a name=id16></a>В этом примере использовались все оси.</td></tr>
  <tr>
    <td><a href="17.htm">Страница&nbsp;17</a></td>
    <td><a name=id17></a>Ось child:: может быть опущена в пути адресации, так как она является осью по умолчанию. Ось attribute:: можно кратко записать в виде @. // является сокращением для /descendant-or-self::, . является синомимом для self::, а .. является сокращением для parent::.</td></tr></tbody></table>
<h3>Повторение и сортировка</h3>
<table cellPadding=5 border=1>
  <tbody>
  <tr>
    <td><a href="18.htm">Страница&nbsp;18</a></td>
    <td><a name=id18></a>Инструкция <code>xsl:for-each</code> определяет шаблон, который применяется для каждого узла, выбранного с помощью атрибута <code>select</code>.</td></tr>
  <tr>
    <td><a href="19.htm">Страница&nbsp;19</a></td>
    <td><a name=id19></a>Узлы, выбранные с помощью <code>xsl:for-each</code> (<a href="19.htm#id4">это</a> и <a href="#id5">это преобразования</a>) или <code>xsl:apply-templates</code> (<a href="19.htm#id6">это преобразование</a>) можно отсортировать. Порядок сортировки определяется атрибутом <code>order</code>. В <a href="19.htm#id4">этом преобразовании</a> проводится сортировка по возрастанию, а в <a href="19.htm#id5">этом</a> &mdash; по убыванию.</td></tr>
  <tr>
    <td><a href="20.htm">Страница&nbsp;20</a></td>
    <td><a name=id20></a>В <a href="20.htm#id2">этом преобразовании</a> сортировка проводится в текстовом режиме, а в <a href="20.htm#id3">этом</a> &mdash; в числовом. Обратите внимание на важную деталь. В алфавите 2 идет после 1, поэтому в текстовом режиме 2 идет после 10.</td></tr>
  <tr>
    <td><a href="21.htm">Страница&nbsp;21</a></td>
    <td><a name=id21></a>В <a href="21.htm#id2">этом преобразовании</a> при сортировке первыми идут символы верхнего регистра, а в <a href="21.htm#id3">этом</a> &mdash; нижнего регистра.</td></tr></tbody></table>
<h3>Создание элементов и атрибутов</h3>
<table cellPadding=5 border=1>
  <tbody>
  <tr>
    <td><a href="22.htm">Страница&nbsp;22</a></td>
    <td><a name=id22></a>С помощью <code>xsl:element</code> в процессе обработки можно создавать новые элементы. В <a href="22.htm#id2">этом преобразовании</a> используется эта возможность, в то время как в <a href="22.htm#id3">этом</a> точно такой же результат достигается другим, более трудоемким способом.</td></tr>
  <tr>
    <td><a href="23.htm">Страница&nbsp;23</a></td>
    <td><a name=id23></a>Инструкция <code>xsl:attribute</code> также служит для генерирования элементов в процессе обработки. Она предназначена для создания атрибутов элемента, в который она заключена.</td></tr>
  <tr>
    <td><a href="24.htm">Страница&nbsp;24</a></td>
    <td><a name=id24></a>Инструкции <code>copy</code> и <code>copy-of</code> используются для копирования узлов в результирующее дерево. Инструкция <code>copy</code> копирует только текущий узел без дочерних элементов и атрибутов, в то время как <code>copy-of</code> &mdash; все.</td></tr>
  <tr>
    <td><a href="25.htm">Страница&nbsp;25</a></td>
    <td><a name=id25></a>Элемент <code>xsl:copy</code> может иметь атрибут <code>use-attribute-sets</code>. В этом случае можно определить атрибуты для копируемого элемента. <a href="25.htm#id3">Это преобразование</a> не будет выполняться, как ожидалось (установка <code>use-attribute-sets</code> при помощи функции <code>name</code>), так как выражения в атрибутах, относящиеся к именованным XSLT-объектам не могут быть вычислены.</td></tr></tbody></table>
<h3>Условная обработка</h3>
<table cellPadding=5 border=1>
  <tbody>
  <tr>
    <td><a href="26.htm">Страница&nbsp;26</a></td>
    <td><a name=id26></a>Инструкция <code>xsl:if</code> позволяет реализовывать условные конструкции. <a href="26.htm#id2">Это преобразование</a> демонстрирует типичный случай использования инструкции <code>xsl:for-each</code>, добавляя текст между отдельными компонентами. Однако, зачастую вы не захотите добавлять текст после последнего элемента. Здесь вам может помочь инструкция <code>xsl-if</code> (<a href="26.htm#id3">это преобразование</a>).</td></tr>
  <tr>
    <td><a href="27.htm">Страница&nbsp;27</a></td>
    <td><a name=id27></a>Элемент <code>xsl:choose</code> используется для организации выбора между несколькими возможностями.</td></tr>
  <tr>
    <td><a href="28.htm">Страница&nbsp;28</a></td>
    <td><a name=id28></a>Как выяснить, что некоторый текст начинается с цифры.</td></tr></tbody></table>
<h3>Создание и форматирование чисел</h3>
<table cellPadding=5 border=1>
  <tbody>
  <tr>
    <td><a href="29.htm">Страница&nbsp;29</a></td>
    <td><a name=id29></a><a href="29.htm#id2">Это преобразование</a> демонстрирует поведение по умолчанию элемента <code>xsl:number</code>. Нумерация конкретных разделов зависит от позиции элемента <code>chapter</code>. Нумерация на каждом уровне идет независимо. Установка атрибута <code>level</code> равным значению "multiple" в <a href="29.htm#id3">этом преобразовании</a> позволяет осуществить более естественную нумерацию.</td></tr>
  <tr>
    <td><a href="30.htm">Страница&nbsp;30</a></td>
    <td><a name=id30></a><code>xsl:number</code> вставляет отформатированные числа в выходной поток. Формат задается с помощью атрибута <code>format</code>. Значение атрибута начинается с идентификатора формата, сопровождаемым символами разделителей. Изучите примеры, приведенные ниже, для сравнения нотации.</td></tr>
  <tr>
    <td><a href="31.htm">Страница&nbsp;31</a></td>
    <td><a name=id31></a><a href="31.htm#id2">Это</a> и <a href="31.htm#id3">это преобразования</a> являются примерами форматирования многоуровневых числовых конструкций.</td></tr></tbody></table>
<h3>Переменные</h3>
<table cellPadding=5 border=1>
  <tbody>
  <tr>
    <td><a href="32.htm">Страница&nbsp;32</a></td>
    <td><a name=id32></a>В <a href="32.htm#id2">Этом</a> и <a href="32.htm#id4">этом преобразованиях</a> демонстрируются различные способы задания <code>xsl:variable</code>, а в <a href="32.htm#id3">этом</a> и в <a href="32.htm#id5">этом преобразованиях</a> &mdash; <code>xsl:param</code>.</td></tr>
  <tr>
    <td><a href="33.htm">Страница&nbsp;33</a></td>
    <td><a name=id33></a>Преобразование может содержать несколько переменных с одинаковыми именами. В <a href="33.htm#id2">этом преобразовании</a> демонстрируется способ, как возвращать значение глобальной переменной, которая имеет такое же имя, как и локальная. В <a href="33.htm#id3">этом преобразовании</a> демонстрируется неверный вариант. Область видимости локальной переменной ограничивается элементом <code>xsl:when</code>. Поэтому в остальной части шаблона видима только глобальная переменная.</td></tr>
  <tr>
    <td><a href="34.htm">Страница&nbsp;34</a></td>
    <td><a name=id34></a>Параметры шаблону можно передать при помощи элемента <code>xsl:with-param</code>. Если шаблон содержит элемент <code>xsl:param</code> с таким же атрибутом <code>name</code>, что и <code>xsl:with-param</code>, то его значение будет использовано. <a href="34.htm#id2">Это преобразование</a> является типичным примером. Если вы хотите передать переменную, то надо определить эту переменную при помощи элемента <code>xsl:param</code>. Примером неправильного подхода может служить <a href="34.htm#id3">это преобразование</a>.</td></tr>
  <tr>
    <td><a href="35.htm">Страница&nbsp;35</a></td>
    <td><a name=id35></a>Переменная может в качестве своего значения держать фрагмент результирующего дерева. Операции, допустимые на фрагменте результирующего дерева, являются подмножеством допустимых на множестве узлов. Операции допустимы на фрагменте результирующего дерева только, если эти операции будут допустимыми над строкой (операция над строкой может сначала вызывать преобразование строки в число или булевую переменную). В частности, на фрагменте результирующего дерева нельзя использовать операторы "/", "//" и "[]". Когда допустимая операция выполняется на фрагменте результирующего дерева, она выполняется точно так, как она должна была быть выполнена на эквивалентном множестве узлов. Сравните <a href="35.htm#id2">это</a> и <a href="35.htm#id3">это преобразования</a>.
</td></tr>
  <tr>
    <td><a href="36.htm">Страница&nbsp;36</a></td>
    <td><a name=id36></a>Есть тонкий момент при задании значения переменной.</td></tr></tbody></table>
<h3>Численные вычисления</h3>
<table cellPadding=5 border=1>
  <tbody>
  <tr>
    <td><a href="37.htm">Страница&nbsp;37</a></td>
    <td><a name=id37></a>Функция <code>number</code> явным образом конвертирует свой аргумент в число. <a href="37.htm#id2">Это преобразование</a> является примером конвертации строк, а <a href="37.htm#id3">это преобразование</a> &mdash; примером конвертации булевских переменных <code>true</code> и <code>false</code>.</td></tr>
  <tr>
    <td><a href="38.htm">Страница&nbsp;38</a></td>
    <td><a name=id38></a>Сложение, вычитание и умножение осуществляется обычным способом (<a href="38.htm#id2">это преобразование</a>). Синтаксис для деления немного отличается от традиционного. Символ "/" зарезервирован для путей адресации и вместо него для обозначения деления используется ключевое слово div (<a href="38.htm#id3">это преобразование</a>). Оператор mod возвращает остаток от деления нацело (<a href="38.htm#id3">это преобразование</a>).</td></tr>
  <tr>
    <td><a href="39.htm">Страница&nbsp;39</a></td>
    <td><a name=id39></a>Функция <code>sum()</code> суммирует все числа из выбранного множества узлов. В <a href="39.htm#id2">этом преобразовании</a> суммируются все числа, а в <a href="39.htm#id3">этом</a> &mdash; только нечетные.</td></tr>
  <tr>
    <td><a href="40.htm">Страница&nbsp;40</a></td>
    <td><a name=id40></a>Функции <code>ceilng()</code>, <code>floor()</code> и <code>round()</code> преобразуют числа с плавающей запятой в целые определенным способом.</td></tr>
  <tr>
    <td><a href="41.htm">Страница&nbsp;41</a></td>
    <td><a name=id41></a>Функция <code>string()</code> преобразует свой аргумент к строковому типу. Эта функция обычно не используется явно в преобразованиях, так как в большинстве случаев она вызывается по умолчанию. <a href="41.htm#id2">Это преобразование</a> является примером преобразования чисел к строковому типу. Обратите внимание на результат деления на 0.</td></tr>
  <tr>
    <td><a href="42.htm">Страница&nbsp;42</a></td>
    <td><a name=id42></a>Пример проверки на то, что тестовое значение является числом.</td></tr></tbody></table>
<h3>Булевые функции</h3>
<table cellPadding=5 border=1>
  <tbody>
  <tr>
    <td><a href="43.htm">Страница&nbsp;43</a></td>
    <td><a name=id43></a>В <a href="43.htm#id2">этом преобразовании</a> строки являются аргументами функции <code>boolean()</code>. Строка является "истиной" тогда и только тогда, когда ее длина ненулевая. В <a href="43.htm#id3">этом преобразовании</a> текст конвертируется в числовой тип, а затем передается в качестве аргументов функции <code>boolean()</code>. <a href="43.htm#id4">Это преобразование</a> показывает разницу между тем, когда "0" является числом, и когда &mdash; строкой. В <a href="43.htm#id5">этом преобразовании</a> в качестве аргумента функции <code>boolean()</code> используется подмножество узлов.</td></tr>
  <tr>
    <td><a href="44.htm">Страница&nbsp;44</a></td>
    <td><a name=id44></a>Функция <code>not()</code> возвращает "истину", если аргументом была "ложь", и "ложь" в противном случае.</td></tr>
  <tr>
    <td><a href="45.htm">Страница&nbsp;45</a></td>
    <td><a name=id45></a>Функции <code>true()</code> и <code>false()</code> обычно используются для проверки некоторых условий в процессе программирования.</td></tr>
  <tr>
    <td><a href="46.htm">Страница&nbsp;46</a></td>
    <td><a name=id46></a>Функция <code>lang()</code> возвращает "истину" или "ложь" в зависимости от того, совпадает ли язык контекстного узла с идентификатором языка, переданным ей в качестве параметра. Она действует следующим образом. Язык контекстного узла определяется значением атрибута <code>xml:lang</code> или, если не контекстный узел не имеет такого атрибута, значением атрибута <code>xml:lang</code> ближайшего предка контекстного узла. Если ни один из предков контекстного узла не имеет атрибута <code>xml:lang</code>, то функция <code>lang()</code> возвращает "ложь". Если же такой атрибут имеется, то функция <code>lang()</code> возвращает "истину", если значения атрибута и аргумента совпадают независимо от регистра символов, или значение атрибута имеет суффикс, начинающийся с символа "-", и его часть до суффикса совпадает со значением аргумента независимо от регистра символов.</td></tr></tbody></table>
<h3>Строковые функции</h3>
<table cellPadding=5 border=1>
  <tbody>
  <tr>
    <td><a href="47.htm">Страница&nbsp;47</a></td>
    <td><a name=id47></a>Функция <code>string()</code> преобразует свой аргумент к строковому типу. Эта функция обычно не используется явно в преобразованиях, так как в большинстве случаев она вызывается по умолчанию. <a href="47.htm#id2">Это преобразование</a> является примером конвертации чисел в строковой тип. Обратите внимание на результат деления на 0.</td></tr>
  <tr>
    <td><a href="48.htm">Страница&nbsp;48</a></td>
    <td><a name=id48></a>Функция <code>concat()</code> возвращает конкатенацию своих аргументов.</td></tr>
  <tr>
    <td><a href="49.htm">Страница&nbsp;49</a></td>
    <td><a name=id49></a>Функция <code>starts-with()</code> принимает на вход два строковых аргумента и возвращает "истину", если первая строка начинается второй, и "ложь" в противном случае. Функция <code>contains()</code> также принимает на вход два строковых аргумента и возвращает "истину", если первая строка содержит вторую, и "ложь" в противном случае.</td></tr>
  <tr>
    <td><a href="50.htm">Страница&nbsp;50</a></td>
    <td><a name=id50></a>Функции <code>substring-before()</code> и <code>substring-after()</code> находят в первой строке вторую. Первая из них возвращает подстроку, которая ей предшествует, а вторая &mdash; подстроку, котороя за ней следует.
Функция <code>substring()</code> возвращает подстроку переданного ей строкового аргумента, начинающуюся с позиции, определенной вторым аргументом, и длиной, определенной в третьем аргументе. Если третий аргумент опущен, то она возвращает подстрока продолжается до конца строки. Позицией первого символа является 1 (<a href="50.htm#id2">это преобразование</a>). <a href="50.htm#id3">Это преобразование</a> демонстрирует ситуацию, когда некоторые аргументы выходят за допустимый диапазон или не являются целыми. Возращаемая строка содержит те символы, для которых позиция больше или равна, чем значение второго аргумента и, если третий аргумент определен, меньше, чем сумма значений второго и третьего аргументов.</td></tr>
  <tr>
    <td><a href="51.htm">Страница&nbsp;51</a></td>
    <td><a name=id51></a>Функция <code>string-length()</code> возвращает количество символов в строке. Функция <code>normalize-space()</code> производит так называемую нормализацию строкового аргумента относительно пробелов. Она удаляет пробелы в начале и в конце строки, а все последовательности пробелов в теле строки заменяются одиночным пробелом.</td></tr>
  <tr>
    <td><a href="52.htm">Страница&nbsp;52</a></td>
    <td><a name=id52></a>Функция <code>translate()</code> возвращает строку из первого аргумента, в которой символы из второго строкового аргумента в соответствии с их позицией заменены на символы из третьего строкового аргумента. Если какой-либо символ встречается во втором аргументе более, чем один раз, то учитывается только первое его появление. Если строка из третьего аргумента длиннее, чем строка из второго аргумента, то остаток строки игнорируется.</td></tr></tbody></table>
<h3>Функции множеств узлов</h3>
<table cellPadding=5 border=1>
  <tbody>
  <tr>
    <td><a href="53.htm">Страница&nbsp;53</a></td>
    <td><a name=id53></a>Функция <code>position()</code> возвращает позицию контекста &mdash; число, равное порядковому номеру контекстного узла в обрабатываемом в данный момент множестве. Функция <code>last()</code> возвращает размер контекста &mdash; число, равное количеству узлов в обрабатываемом множестве. <a href="53.htm#id2">Это преобразование</a> является демонстрацией использования этих функций в некоторых контекстах. В <a href="53.htm#id3">этом преобразовании</a> демонстрируется действие этих функций на отсортированные и неотсортированные множества узлов внутри элемента <code>xsl:for-each</code>.</td></tr>
  <tr>
    <td><a href="54.htm">Страница&nbsp;54</a></td>
    <td><a name=id54></a>Функция <code>count()</code> возвращает количество узлов в множестве, переданном ей в качестве аргумента.</td></tr>
  <tr>
    <td><a href="55.htm">Страница&nbsp;55</a></td>
    <td><a name=id55></a>Функция <code>id()</code> позволяет обращаться к элементам по значениям их уникальных идентификаторов. <a href="55.htm#id2">Это преобразование</a> является простым примером ее использования. Тщательно изучите <a href="55.htm#id3">это преобразование</a>. Содержание элемента <code>title</code> не отображается внутри квадратных скобок, так как в DTD его атрибут <code>id</code> определен как CDATA, а не как ID. Одновременно можно обрабатывать несколько идентификаторов (<a href="55.htm#id4">это преобразование</a>).</td></tr>
  <tr>
    <td><a href="56.htm">Страница&nbsp;56</a></td>
    <td><a name=id56></a>Пример использования функции <code>id()</code>.</td></tr>
  <tr>
    <td><a href="57.htm">Страница&nbsp;57</a></td>
    <td><a name=id57></a>Функции <code>name()</code>, <code>local-name()</code> и <code>namespace-uri()</code> используются для получения информации имени элемента или атрибута и пространстве имен.</td></tr></tbody></table>
<h3>Вывод</h3>
<table cellPadding=5 border=1>
  <tbody>
  <tr>
    <td><a href="58.htm">Страница&nbsp;58</a></td>
    <td><a name=id58></a>Элемент <code>xsl:output</code> позволяет авторам преобразований определять, в каком виде должно быть представлено результирующее дерево. Если XSLT-процессор выводит результирующее дерево, то он должен делать это в точности так, как определено элементом <code>xsl:output</code>. Элемент <code>xsl:output</code> является элементом только верхнего уровня. В <a href="58.htm#id2">этом преобразовании</a> используется метод вывода "html", а в <a href="58.htm#id3">этом</a> &mdash; "xml". Сравните вывод пустых элементов.</td></tr>
  <tr>
    <td><a href="59.htm">Страница&nbsp;59</a></td>
    <td><a name=id59></a>Если элемент <code>xml:output</code> отсутствует, то по умолчанию методом вывода бедет "xml" (<a href="59.htm#id2">это преобразование</a>), однако, если корневой элемент выходного документа имеет значение "html" (независимо от регистра символов), то методом вывода будет "html" (<a href="59.html#id3">это преобразование</a>).</td></tr>
  <tr>
    <td><a href="60.htm">Страница&nbsp;60</a></td>
    <td><a name=id60></a>Метод вывода "html" для пустых элементов, определенных спецификацией HTML, выводит тэги без косой черты после имени и закрывающих тэгов. Также при использовании этого метода вывода процессор не должен анализировать содержимое элементов <code>script</code> и <code>style</code>. Сравните с <a href="60.htm#id3">этим преобразованием</a>. Для получения более подробной информации обратитесь к Спецификации XSLT.</td></tr>
  <tr>
    <td><a href="61.htm">Страница&nbsp;61</a></td>
    <td><a name=id61></a>Атрибут <code>encoding</code> определяет, какая кодировка предпочтительна для выходящего документа. Метод вывода "html" должен добавить непосредственно за открывающим тэгом элемента <code>HEAD</code> элемент <code>META</code> с определением используемой кодировки. <a href="61.htm#id2">Это преобразование</a> использует для вывода кодировку UTF-8, <a href="61.htm#id3">это преобразование</a> &mdash;  UTF-16, а <a  href="61.htm#id4">это</a> &mdash; Cp1250. <!-- Обратите внимание на <a href="61.htm#id5">это преобразование</a>. Исходный xml содержит символы, которые не присутствуют в  ссылающейся таблице символов, поэтому они опускаются.--></td></tr>
  <tr>
    <td><a href="62.htm">Страница&nbsp;62</a></td>
    <td><a name=id62></a>Метод вывода "text" выводит результирующее дерево посредством вывода строковых значений каждого текстового узла в порядке следования в документе без каких-либо изменений.</td></tr></tbody></table>
<h3>Копирование</h3>
<table cellPadding=5 border=1>
  <tbody>
  <tr>
    <td><a href="63.htm">Страница&nbsp;63</a></td>
    <td><a name=id63></a>Инструкции <code>copy</code> и <code>copy-of</code> используются для копирования узлов в результирующее дерево. Инструкция <code>copy</code> копирует только текущий узел без дочерних элементов и атрибутов, в то время как <code>copy-of</code> &mdash; все.</td></tr>
  <tr>
    <td><a href="64.htm">Страница&nbsp;64</a></td>
    <td><a name=id64></a>Элемент <code>xsl:copy</code> может иметь атрибут <code>use-attribute-sets</code>. В этом случае можно определить атрибуты для копируемого элемента. <a href="64.htm#id3">Это преобразование</a> не будет выполняться, как ожидалось (установка <code>use-attribute-sets</code> при помощи функции <code>name</code>), так как выражения в атрибутах, относящиеся к именованным XSLT-объектам не могут быть вычислены.</td></tr></tbody></table>
<h3>Дополнительные функции</h3>
<table cellPadding=5 border=1>
  <tbody>
  <tr>
    <td><a href="65.htm">Страница&nbsp;65</a></td>
    <td><a name=id65></a>Функция <code>current()</code> возвращает множество, состоящее только из текущего узла преобразования. Для наиболее удаленых выражений (выражений, не встречающихся внутри других выражений), текущий узел всегда совпадает с узлом контекста. Однако, внутри квадратных скобок обычно они являются двумя различными узлами.</td></tr>
  <tr>
    <td><a href="66.htm">Страница&nbsp;66</a></td>
    <td><a name=id66></a>Функция <code>generate-id()</code> используется для создания уникального идентификатора, отвечающего Спецификации XML. <a href="66.htm#id3">Это преобразование</a> использует эту функцию для добавления идентификатора ко всем элементам исходного XML.</td></tr></tbody></table>
<h3>Комбинирование преобразований</h3>
<table cellPadding=5 border=1>
  <tbody>
  <tr>
    <td><a 
      href="67.htm">Страница&nbsp;67</a></td>
    <td><a name=id67></a>В преобразование можно импортировать (<code>xsl:import</code>) и включать (<code>xsl:include</code>) внешните файлы преобразований. Импортирование почти полностью аналогично включению за исключением того, что определения и шаблоны в основном файле имеют превосходство над шаблонами и определениями в импортируемых файлах. <a href="67.htm#id2">Это</a> и <a href="67.htm#id3">это преобразования</a> импортируются или включаются в остальные.</td></tr>
  <tr>
    <td><a href="68.htm">Страница&nbsp;68</a></td>
    <td><a name=id68></a>В <a href="68.htm#id4">это преобразование</a> включается <a href="68.htm#id3">это</a>, в <a href="68.htm#id3">которое</a>, в свою очередь, импортируется <a href="68.htm#id2">это преобразование</a>.</td></tr>
  <tr>
    <td><a href="69.htm">Страница&nbsp;69</a></td>
    <td><a name=id69></a>Другие примеры использования <code>xsl:include</code> и <code>xsl:import</code>.</td></tr>
  <tr>
    <td><a href="70.htm">Страница&nbsp;70</a></td>
    <td><a name=id70></a>Вы можете использовать элемент <code>xsl:apply-imports</code> для использования импортированных шаблонов, чье поведение, однако, вы можете изменить. В <a href="70.htm#id3">это преобразование</a> импортируется <a href="70.htm#id2">это</a>, а его шаблоны аннулируются. <a href="70.htm#id4">Это преобразование</a> импортирует <a href="70.htm#id2">это</a> и изменяет его шаблоны. Инструкция <code>xsl:apply-imports</code> работает только для шаблонов импортированных с помощью <code>xsl:import</code>, а не включенных с помощью <code>xsl:include</code> (<a href="70.htm#id5">это преобразование</a>).</td></tr>
  <tr>
    <td><a 
      href="71.htm">Страница&nbsp;71</a></td>
    <td><a name=id71></a>Превосходство при импорте сильней, чем превосходство приоритета. Смотрите <a href="71.htm#id3">это преобразование</a>.</td></tr></tbody></table></body></html>